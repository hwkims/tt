<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>이모지 매칭 퍼즐 게임</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            touch-action: none; /* 스크롤, 확대 방지 */
        }
        .background-video {
             position: fixed;
             top: 0;
            left: 0;
            width: 100%;
            height: 100%;
             z-index: -1;
        }
        .background-video iframe {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .game-container {
            position: absolute;
            top: 0;
            left: 0;
             width: 100%;
             height: 100%;
             display: flex;
            justify-content: center;
           align-items: center;
         }
         .game-board {
            position: relative;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
         .layer {
             position: absolute;
            display: grid;
            grid-gap: 5px;
             transition: all 0.3s ease;
         }
        .tile {
             width: 50px;
             height: 50px;
             font-size: 28px;
            background-color: rgba(255, 255, 255, 0.9);
             display: flex;
            align-items: center;
            justify-content: center;
             cursor: pointer;
             border-radius: 10px;
              box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, background-color 0.2s ease;
            user-select: none;
             z-index: 1;
           position: relative;
        }
        .tile.selected {
             transform: scale(1.1);
             background-color: rgba(240, 240, 240, 0.9);
              box-shadow: 0 4px 8px rgba(0,0,0,0.2);
             z-index: 2;
         }
        .tile.matched {
            animation: fadeOut 0.5s forwards;
         }
         .ui-container{
           display: flex;
             flex-direction: column;
           position: absolute;
           top: 20px;
            right: 20px;
            color: white;
         }
         .score{
            font-size: 20px;
         }
        .hint-button{
            margin-top: 10px;
            background-color: #4CAF50;
           color: white;
            padding: 10px 20px;
             border: none;
             border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .hint-button:hover{
             background-color: #367c39;
        }
        @keyframes fadeOut {
           from {
                opacity: 1;
            }
           to {
                opacity: 0;
               transform: scale(0);
            }
        }
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
           pointer-events: none;
             z-index: 9999;
         }
        .confetti {
             position: absolute;
             width: 10px;
             height: 10px;
             background-color: gold;
             border-radius: 50%;
             animation: confettiFall 5s ease-out infinite;
        }
        @keyframes confettiFall {
           0% {
               opacity: 1;
               transform: translateY(0) rotate(0deg);
           }
            100% {
                opacity: 0;
               transform: translateY(100vh) rotate(720deg);
             }
         }
        .game-complete-message {
           position: absolute;
            top: 50%;
             left: 50%;
           transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
           text-shadow: 2px 2px 4px #000;
           text-align: center;
          display: none;
         }
         .level-transition {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
            height: 100%;
           background-color: rgba(0,0,0,0.8);
            display: flex;
           justify-content: center;
             align-items: center;
            font-size: 48px;
             color: white;
             z-index: 10000;
             opacity: 0;
             pointer-events: none;
              transition: opacity 0.5s ease;
        }
        .level-transition.active {
          opacity: 1;
         }
    </style>
</head>
<body>
    <div class="background-video">
         <iframe src="https://www.youtube.com/embed/videoseries?list=PLmqlw16J0698OoM1eYZOf1N9fxhauLNVB&autoplay=1&loop=1&playlist=PLmqlw16J0698OoM1eYZOf1N9fxhauLNVB" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
    <div class="game-container">
      <div class="game-board">
        </div>
       <div class="ui-container">
           <div class="score">Score: 0</div>
          <button class="hint-button">Hint</button>
       </div>
         <div class="game-complete-message">훌륭해요!</div>
       <div class="confetti-container"></div>
        <div class="level-transition"></div>
     </div>
    <script>
         const gameBoard = document.querySelector('.game-board');
         const scoreDisplay = document.querySelector('.score');
         const hintButton = document.querySelector('.hint-button');
         const confettiContainer = document.querySelector('.confetti-container');
         const gameCompleteMessage = document.querySelector('.game-complete-message');
          const levelTransition = document.querySelector('.level-transition');

          let tiles = [];
         let selectedTiles = [];
         let score = 0;
        let hintAvailable = true;
        let currentLevel = 1;
        let gameCompleted = false;
         let combo = 1;
         let canClick = true; // 추가

        // 원본 게임 참고하여 이모지 종류 추가
       const emojis = [
            '🍎', '🍌', '🍇', '🍉', '🥝', '🍓', '🍋', '🍊', '🍍', '🥭',
            '🥑', '🍒', '🍑', '🥥', '🥝', '🫐', '🍅', '🥔', '🥕', '🌶️',
             '🌽', '🍄', '🥜', '🌰', '🥐', '🥯', '🥨', '🍟', '🍕', '🍔'
            ];
        function generateLevel(level) {
          gameBoard.innerHTML = '';
             tiles = [];
           const layersCount = Math.ceil(level / 2) + 2;
             const baseLayerSize = 3;

           for (let layerIndex = 0; layerIndex < layersCount; layerIndex++) {
              const layer = document.createElement('div');
                layer.classList.add('layer');
               gameBoard.appendChild(layer);
              const layerSize = baseLayerSize + layerIndex * 2;
                layer.style.gridTemplateColumns = `repeat(${layerSize}, 50px)`;
                layer.style.transform = `translateY(${layerIndex * 10}px)`;


                for (let row = 0; row < layerSize; row++) {
                  for (let col = 0; col < layerSize; col++){
                      if(Math.random() > 0.15){ // 타일 생성 확률
                          const tile = document.createElement('div');
                            tile.classList.add('tile');
                          tile.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                           tile.dataset.row = row;
                          tile.dataset.col = col;
                         tile.dataset.layer = layerIndex;
                          tile.dataset.index = tiles.length;
                        tile.addEventListener('click', () => handleTileClick(tile));
                       tiles.push(tile);


                        const offsetX =  ((gameBoard.offsetWidth - (layerSize*50 + (layerSize -1)*5))/2)
                          tile.style.left = offsetX + (col * 50) + (col * 5) + 'px';
                          tile.style.top = ((gameBoard.offsetHeight - (layerSize*50 + (layerSize -1)*5))/2) + (row*50) + (row * 5) - (layerIndex * 20) + 'px';
                       layer.appendChild(tile);
                     }
                  }
              }
          }
        }

        function handleTileClick(tile) {
          if (!canClick || gameCompleted || tile.classList.contains('matched') || selectedTiles.length >= 2) return;
             canClick = false; // 클릭 막기
             tile.classList.add('selected');
            selectedTiles.push(tile);


            if(selectedTiles.length === 2) {
                setTimeout(checkMatch, 300); // 0.3초 딜레이
            } else {
                 canClick = true;
            }
        }
         function checkMatch(){
             const [tile1, tile2] = selectedTiles;

            if (tile1.textContent === tile2.textContent && !areTilesAdjacent(tile1, tile2)) {

                tile1.classList.remove('selected');
               tile2.classList.remove('selected');
              selectedTiles = [];

             }
           else if (tile1.textContent === tile2.textContent) {
                tile1.classList.add('matched');
                tile2.classList.add('matched');
                setTimeout(() => {
                   tile1.remove();
                  tile2.remove();
                 score += 10 * combo;
                   scoreDisplay.textContent = 'Score: ' + score;
                  selectedTiles = [];
                    if(isGameComplete()){
                       handleGameComplete();
                 }
                    combo++;
                   canClick = true;
              },300);

          } else {
               tile1.classList.remove('selected');
                 tile2.classList.remove('selected');
                selectedTiles = [];
                 combo = 1; // 콤보 초기화
               canClick = true; // 클릭 허용
            }
        }

        function areTilesAdjacent(tile1, tile2) {
             const row1 = parseInt(tile1.dataset.row);
            const col1 = parseInt(tile1.dataset.col);
             const layer1 = parseInt(tile1.dataset.layer);
             const row2 = parseInt(tile2.dataset.row);
             const col2 = parseInt(tile2.dataset.col);
            const layer2 = parseInt(tile2.dataset.layer);

           if (layer1 !== layer2) return false;

              return Math.abs(row1 - row2) <= 2 && Math.abs(col1 - col2) <= 2;
        }


       function isGameComplete() {
            return tiles.every(tile => tile.classList.contains('matched'));
       }
       function handleGameComplete(){
            gameCompleted = true;
           gameCompleteMessage.style.display = 'block';
           showConfetti();
            setTimeout(() => {
               gameCompleted = false;
               gameCompleteMessage.style.display = 'none';
                currentLevel++;
               updateURL();
               startLevel();
          }, 3000)
      }
       function showConfetti() {
             for (let i = 0; i < 100; i++) {
               const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}%`;
                 confetti.style.animationDelay = `${Math.random() * 2}s`;
               confettiContainer.appendChild(confetti);
            }
           setTimeout(() => {
               confettiContainer.innerHTML = '';
             }, 5000);
        }
       function showHint() {
           if (!hintAvailable) return;
             const unmatchedTiles = tiles.filter(tile => !tile.classList.contains('matched'));

             if (unmatchedTiles.length < 2) {
               return;
             }
             const potentialMatches = [];
            for (let i = 0; i < unmatchedTiles.length; i++) {
                 for (let j = i + 1; j < unmatchedTiles.length; j++) {
                   if (unmatchedTiles[i].textContent === unmatchedTiles[j].textContent && areTilesAdjacent(unmatchedTiles[i], unmatchedTiles[j])) {
                        potentialMatches.push([unmatchedTiles[i], unmatchedTiles[j]]);
                     }
               }
            }
           if (potentialMatches.length > 0) {
              const [hintTile1, hintTile2] = potentialMatches[Math.floor(Math.random() * potentialMatches.length)];
               hintTile1.classList.add('selected');
                hintTile2.classList.add('selected');
               setTimeout(() => {
                   hintTile1.classList.remove('selected');
                  hintTile2.classList.remove('selected');
              }, 1000);
              hintAvailable = false;
                 hintButton.disabled = true;
                setTimeout(() => {
                  hintAvailable = true;
                    hintButton.disabled = false;
               }, 3000);
           }
        }
        hintButton.addEventListener('click', showHint);
        function startLevel(){
             showLevelTransition();
            setTimeout(() => {
              generateLevel(currentLevel);
           }, 500);
         }
        function updateURL(){
            const params = new URLSearchParams(window.location.search);
           params.set('level', currentLevel);
           window.history.pushState({}, '', `${location.pathname}?${params}`);
         }
         function getLevelFromURL() {
            const params = new URLSearchParams(window.location.search);
           const levelParam = params.get('level');
           return levelParam ? parseInt(levelParam, 10) : 1;
         }
         function showLevelTransition() {
              levelTransition.textContent = `Level ${currentLevel}`;
           levelTransition.classList.add('active');
             setTimeout(() => {
              levelTransition.classList.remove('active');
          }, 1000);
          }

        currentLevel = getLevelFromURL();
       startLevel();
    </script>
</body>
</html>
